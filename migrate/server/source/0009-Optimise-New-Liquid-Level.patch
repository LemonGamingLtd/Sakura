From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Samsuik <kfian294ma4@gmail.com>
Date: Wed, 6 Oct 2021 17:25:27 +0100
Subject: [PATCH] Optimise New Liquid Level


diff --git a/src/main/java/net/minecraft/world/level/material/FlowingFluid.java b/src/main/java/net/minecraft/world/level/material/FlowingFluid.java
index f4fbcbb8ff6d2677af1a02a0801a323c06dce9b1..4613162b6e716e33a838c59171c486b9c4d4b097 100644
--- a/src/main/java/net/minecraft/world/level/material/FlowingFluid.java
+++ b/src/main/java/net/minecraft/world/level/material/FlowingFluid.java
@@ -181,7 +181,7 @@ public abstract class FlowingFluid extends Fluid {
             FluidState fluid1 = iblockdata1.getFluidState();
 
             if (this.canMaybePassThrough(world, fluidPos, blockState, Direction.DOWN, blockposition1, iblockdata1, fluid1)) {
-                FluidState fluid2 = this.getNewLiquid(world, blockposition1, iblockdata1);
+                FluidState fluid2 = this.getLiquid(world, blockposition1, iblockdata1, fluidPos, blockState); // Sakura - optimise new liquid level
                 Fluid fluidtype = fluid2.getType();
 
                 if (fluid1.canBeReplacedWith(world, blockposition1, fluidtype, Direction.DOWN) && FlowingFluid.canHoldSpecificFluid(world, blockposition1, iblockdata1, fluidtype)) {
@@ -245,6 +245,23 @@ public abstract class FlowingFluid extends Fluid {
     }
 
     protected FluidState getNewLiquid(ServerLevel world, BlockPos pos, BlockState state) {
+        // Sakura start - optimise new liquid level
+        final BlockPos abovePos = pos.above();
+        final BlockState aboveState = world.getBlockState(abovePos);
+        return this.getLiquid(world, pos, state, abovePos, aboveState);
+    }
+
+    private FluidState getLiquid(final ServerLevel world, final BlockPos flowToPos, final BlockState flowToState, final BlockPos abovePos, final BlockState aboveState) {
+        final FluidState aboveFluid = aboveState.getFluidState();
+        if (!aboveFluid.isEmpty() && aboveFluid.getType().isSame(this) && FlowingFluid.canPassThroughWall(Direction.UP, world, flowToPos, flowToState, abovePos, aboveState)) {
+            return this.getFlowing(8, true);
+        } else {
+            return this.getLiquidFromSurroundings(world, flowToPos, flowToState);
+        }
+    }
+
+    private FluidState getLiquidFromSurroundings(final ServerLevel world, final BlockPos pos, final BlockState state) {
+        // Sakura start - optimise new liquid level
         int i = 0;
         int j = 0;
         BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
@@ -275,13 +292,7 @@ public abstract class FlowingFluid extends Fluid {
             }
         }
 
-        BlockPos.MutableBlockPos blockposition_mutableblockposition2 = blockposition_mutableblockposition.setWithOffset(pos, Direction.UP);
-        BlockState iblockdata3 = world.getBlockState(blockposition_mutableblockposition2);
-        FluidState fluid2 = iblockdata3.getFluidState();
-
-        if (!fluid2.isEmpty() && fluid2.getType().isSame(this) && FlowingFluid.canPassThroughWall(Direction.UP, world, pos, state, blockposition_mutableblockposition2, iblockdata3)) {
-            return this.getFlowing(8, true);
-        } else {
+        { // Sakura - optimise new liquid level
             int k = i - this.getDropOff(world);
 
             return k <= 0 ? Fluids.EMPTY.defaultFluidState() : this.getFlowing(k, false);
