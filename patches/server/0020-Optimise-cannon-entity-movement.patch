From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Samsuik <40902469+Samsuik@users.noreply.github.com>
Date: Fri, 13 Oct 2023 14:36:19 +0100
Subject: [PATCH] Optimise cannon entity movement


diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index c8b33f6d5b820da4b9e16b7d251ca4aad1875aa8..fcb0df76474b641ea86eeb87755faead66397d26 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -1249,6 +1249,75 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         return this.moveStartZ;
     }
     // Paper end - detailed watchdog information
+    // Sakura start - optimise cannon entity movement; stripped back movement method
+    public final void moveStripped(MoverType movementType, Vec3 movement) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread("Cannot move an entity off-main");
+        if (this.noPhysics) {
+            this.setPos(this.getX() + movement.x, this.getY() + movement.y, this.getZ() + movement.z);
+        } else {
+            if (movementType == MoverType.PISTON) {
+                movement = this.limitPistonMovement(movement);
+                if (movement.equals(Vec3.ZERO)) {
+                    return;
+                }
+            }
+
+            ProfilerFiller gameprofilerfiller = Profiler.get();
+            gameprofilerfiller.push("move");
+            if (this.stuckSpeedMultiplier.lengthSqr() > 1.0E-7D) {
+                movement = movement.multiply(this.stuckSpeedMultiplier);
+                this.stuckSpeedMultiplier = Vec3.ZERO;
+                this.setDeltaMovement(Vec3.ZERO);
+            }
+
+            Vec3 vec3d1 = this.sakura_collide(movement);
+            double d0 = vec3d1.lengthSqr();
+
+            if (d0 > 1.0E-7D || movement.lengthSqr() - d0 < 1.0E-7D) {
+                if (this.fallDistance != 0.0F && d0 >= 1.0D && !this.isFallingBlock) {
+                    BlockHitResult clipResult = this.level().clip(new ClipContext(this.position(), this.position().add(vec3d1), ClipContext.Block.FALLDAMAGE_RESETTING, ClipContext.Fluid.WATER, this));
+                    if (clipResult.getType() != HitResult.Type.MISS) {
+                        this.resetFallDistance();
+                    }
+                }
+
+                this.setPos(this.getX() + vec3d1.x, this.getY() + vec3d1.y, this.getZ() + vec3d1.z);
+            }
+
+            gameprofilerfiller.pop();
+            gameprofilerfiller.push("rest");
+            boolean movedX = !Mth.equal(movement.x, vec3d1.x);
+            boolean movedZ = !Mth.equal(movement.z, vec3d1.z);
+
+            this.horizontalCollision = movedX || movedZ;
+            this.verticalCollision = movement.y != vec3d1.y;
+            this.verticalCollisionBelow = this.verticalCollision && movement.y < 0.0D;
+
+            this.setOnGroundWithMovement(this.verticalCollisionBelow, this.horizontalCollision, vec3d1);
+            BlockPos blockPosBelow = this.getOnPosLegacy();
+            BlockState blockstate = this.level().getBlockState(blockPosBelow);
+
+            this.checkFallDamage(vec3d1.y, this.onGround(), blockstate, blockPosBelow);
+            if (this.isRemoved()) {
+                gameprofilerfiller.pop();
+            } else {
+                if (this.horizontalCollision) {
+                    Vec3 vec3d2 = this.getDeltaMovement();
+                    this.setDeltaMovement(movedX ? 0.0D : vec3d2.x, vec3d2.y, movedZ ? 0.0D : vec3d2.z);
+                }
+
+                Block block = blockstate.getBlock();
+                if (movement.y != vec3d1.y) { // remove y momentum
+                    block.updateEntityMovementAfterFallOn(this.level(), this);
+                }
+
+                float f = this.getBlockSpeedFactor();
+                this.setDeltaMovement(this.getDeltaMovement().multiply((double) f, 1.0D, (double) f));
+                gameprofilerfiller.pop();
+            }
+        }
+    }
+    // Sakura end -  optimise cannon entity movement; stripped back movement method
 
     public void move(MoverType type, Vec3 movement) {
         final Vec3 originalMovement = movement; // Paper - Expose pre-collision velocity
@@ -1610,6 +1679,107 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         return offsetFactor;
     }
 
+    // Sakura start - optimise cannon entity movement
+    private Vec3 sakura_collide(Vec3 movement) {
+        if (movement.x == 0.0 && movement.y == 0.0 && movement.z == 0.0) {
+            return movement;
+        }
+
+        List<VoxelShape> potentialCollisionsVoxel = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(0);
+        List<AABB> potentialCollisionsBB = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(4);
+        AABB currBoundingBox = this.getBoundingBox();
+
+        if (movement.lengthSqr() >= 12.0) { // axis scan on large movement
+            return this.collideAxisScan(movement, currBoundingBox, potentialCollisionsVoxel, potentialCollisionsBB);
+        } else {
+            return this.collideCube(movement, currBoundingBox, potentialCollisionsVoxel, potentialCollisionsBB);
+        }
+    }
+
+    private Vec3 collideCube(Vec3 movement, AABB currBoundingBox, List<VoxelShape> voxelList, List<AABB> bbList) {
+        final AABB bb;
+        if (movement.x() == 0.0 && movement.z() == 0.0) {
+            if (movement.y > 0.0) {
+                bb = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.cutUpwards(currBoundingBox, movement.y);
+            } else {
+                bb = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.cutDownwards(currBoundingBox, movement.y);
+            }
+        } else {
+            bb = currBoundingBox.expandTowards(movement.x, movement.y, movement.z);
+        }
+        this.collectCollisions(bb, voxelList, bbList);
+        return ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.performCollisions(movement, currBoundingBox, voxelList, bbList);
+    }
+
+    private Vec3 collideAxisScan(Vec3 movement, AABB currBoundingBox, List<VoxelShape> voxelList, List<AABB> bbList) {
+        double x = movement.x;
+        double y = movement.y;
+        double z = movement.z;
+
+        boolean xSmaller = Math.abs(x) < Math.abs(z);
+
+        if (y != 0.0) {
+            y = this.scanY(currBoundingBox, y, voxelList, bbList);
+            if (y != 0.0) {
+                currBoundingBox = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.offsetY(currBoundingBox, y);
+            }
+        }
+
+        if (xSmaller && z != 0.0) {
+            z = this.scanZ(currBoundingBox, z, voxelList, bbList);
+            if (z != 0.0) {
+                currBoundingBox = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.offsetZ(currBoundingBox, z);
+            }
+        }
+
+        if (x != 0.0) {
+            x = this.scanX(currBoundingBox, x, voxelList, bbList);
+            if (x != 0.0) {
+                currBoundingBox = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.offsetX(currBoundingBox, x);
+            }
+        }
+
+        if (!xSmaller && z != 0.0) {
+            z = this.scanZ(currBoundingBox, z, voxelList, bbList);
+        }
+
+        return new Vec3(x, y, z);
+    }
+
+    private void collectCollisions(AABB collisionBox, List<VoxelShape> voxelList, List<AABB> bbList) {
+        // Copied from the collide method below
+        ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getCollisionsForBlocksOrWorldBorder(
+            this.level, this, collisionBox, voxelList, bbList,
+            ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_BORDER  | this.getExtraCollisionFlags(), null // Sakura - load chunks on movement
+        );
+
+        ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getEntityHardCollisions(
+            this.level, this, collisionBox, bbList, 0, null
+        );
+    }
+
+    private double scanX(AABB currBoundingBox, double x, List<VoxelShape> voxelList, List<AABB> bbList) {
+        AABB scanBox = currBoundingBox.expandTowards(x, 0.0, 0.0);
+        this.collectCollisions(scanBox, voxelList, bbList);
+        x = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.performAABBCollisionsX(currBoundingBox, x, bbList);
+        return ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.performVoxelCollisionsX(currBoundingBox, x, voxelList);
+    }
+
+    private double scanY(AABB currBoundingBox, double y, List<VoxelShape> voxelList, List<AABB> bbList) {
+        AABB scanBox = currBoundingBox.expandTowards(0.0, y, 0.0);
+        this.collectCollisions(scanBox, voxelList, bbList);
+        y = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.performAABBCollisionsY(currBoundingBox, y, bbList);
+        return ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.performVoxelCollisionsY(currBoundingBox, y, voxelList);
+    }
+
+    private double scanZ(AABB currBoundingBox, double z, List<VoxelShape> voxelList, List<AABB> bbList) {
+        AABB scanBox = currBoundingBox.expandTowards(0.0, 0.0, z);
+        this.collectCollisions(scanBox, voxelList, bbList);
+        z = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.performAABBCollisionsZ(currBoundingBox, z, bbList);
+        return ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.performVoxelCollisionsZ(currBoundingBox, z, voxelList);
+    }
+    // Sakura end - optimise cannon entity movement
+
     private Vec3 collide(Vec3 movement) {
         // Paper start - optimise collisions
         final boolean xZero = movement.x == 0.0;
diff --git a/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java b/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java
index f0617e9d71fa47dfc0566f31d85b8a05ba3b16fc..32811e9d925911864e0c0fa5a2e25031098f423e 100644
--- a/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java
+++ b/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java
@@ -213,7 +213,7 @@ public class FallingBlockEntity extends Entity implements me.samsuik.sakura.enti
 
             ++this.time;
             this.applyGravity();
-            this.move(MoverType.SELF, this.getDeltaMovement());
+            this.moveStripped(MoverType.SELF, this.getDeltaMovement()); // Sakura - optimise cannon entity movement
             this.applyEffectsFromBlocks();
             // Paper start - Configurable falling blocks height nerf
             if (this.level().paperConfig().fixes.fallingBlockHeightNerf.test(v -> this.getY() > v)) {
diff --git a/src/main/java/net/minecraft/world/entity/item/PrimedTnt.java b/src/main/java/net/minecraft/world/entity/item/PrimedTnt.java
index 0a9e62dd90c6aba4ff97391d69f9a92d9555cae6..7bb55565208b99db095c5842a7e21fd21700173e 100644
--- a/src/main/java/net/minecraft/world/entity/item/PrimedTnt.java
+++ b/src/main/java/net/minecraft/world/entity/item/PrimedTnt.java
@@ -130,7 +130,7 @@ public class PrimedTnt extends Entity implements TraceableEntity, me.samsuik.sak
         if (this.level().spigotConfig.maxTntTicksPerTick > 0 && ++this.level().spigotConfig.currentPrimedTnt > this.level().spigotConfig.maxTntTicksPerTick) { return; } // Spigot
         this.handlePortal();
         this.applyGravity();
-        this.move(MoverType.SELF, this.getDeltaMovement());
+        this.moveStripped(MoverType.SELF, this.getDeltaMovement()); // Sakura - optimise cannon entity movement
         this.applyEffectsFromBlocks();
         // Paper start - Configurable TNT height nerf
         if (this.level().paperConfig().fixes.tntEntityHeightNerf.test(v -> this.getY() > v)) {
