From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Samsuik <kfian294ma4@gmail.com>
Date: Fri, 19 Apr 2024 22:20:03 +0100
Subject: [PATCH] Optimise paper explosions


diff --git a/src/main/java/net/minecraft/world/level/ServerExplosion.java b/src/main/java/net/minecraft/world/level/ServerExplosion.java
index bbbd451ff184be8fa13bd93d53c89a9502f9951a..a92be80081178cc302a7f0b646bad7daa28f7c66 100644
--- a/src/main/java/net/minecraft/world/level/ServerExplosion.java
+++ b/src/main/java/net/minecraft/world/level/ServerExplosion.java
@@ -89,7 +89,7 @@ public class ServerExplosion implements Explosion {
             }
         }
 
-        CACHED_RAYS = rayCoords.toDoubleArray();
+        CACHED_RAYS = sortExplosionRays(rayCoords); // Sakura - optimise paper explosions
     }
 
     private static final int CHUNK_CACHE_SHIFT = 2;
@@ -307,6 +307,39 @@ public class ServerExplosion implements Explosion {
         return (float)missedRays / (float)totalRays;
     }
     // Paper end - collisions optimisations
+    // Sakura start - optimise paper explosions
+    /*
+     * Sort the explosion rays to better utilise the chunk and block cache.
+     *   x +   Vanilla     Sorted
+     * z @ z      8           5
+     * - x      6   7       6   4
+     *        4   @   5   7   @   3
+     *          2   3       8   2
+     *            1           1
+     */
+    private static double[] sortExplosionRays(it.unimi.dsi.fastutil.doubles.DoubleArrayList rayCoords) {
+        List<double[]> explosionRays = new ArrayList<>();
+
+        for (int i = 0; i < rayCoords.size(); i += 3) {
+            double[] ray = new double[3];
+            rayCoords.getElements(i, ray, 0, 3);
+            explosionRays.add(ray);
+        }
+
+        rayCoords.clear();
+        explosionRays.sort(java.util.Comparator.comparingDouble(vec -> {
+            double sign = Math.signum(vec[0]);
+            double dir = (sign - 1) / 2;
+            return sign + 8 + vec[2] * dir;
+        }));
+
+        double[] rays = new double[explosionRays.size() * 3];
+        for (int i = 0; i < explosionRays.size() * 3; i++) {
+            rays[i] = explosionRays.get(i / 3)[i % 3];
+        }
+        return rays;
+    }
+    // Sakura end - optimise paper explosions
 
     public ServerExplosion(ServerLevel world, @Nullable Entity entity, @Nullable DamageSource damageSource, @Nullable ExplosionDamageCalculator behavior, Vec3 pos, float power, boolean createFire, Explosion.BlockInteraction destructionType) {
         this.level = world;
@@ -389,6 +422,12 @@ public class ServerExplosion implements Explosion {
             initialCache = this.getOrCacheExplosionBlock(blockX, blockY, blockZ, key, true);
         }
 
+        // Sakura start - optimise paper explosions
+        if (!this.interactsWithBlocks() || initialCache.resistance > (this.radius * 1.3f)) {
+            return ret;
+        }
+        // Sakura end - optimise paper explosions
+
         // only ~1/3rd of the loop iterations in vanilla will result in a ray, as it is iterating the perimeter of
         // a 16x16x16 cube
         // we can cache the rays and their normals as well, so that we eliminate the excess iterations / checks and
@@ -467,19 +506,55 @@ public class ServerExplosion implements Explosion {
         // Paper end - collision optimisations
     }
 
-    private void hurtEntities() {
-        float f = this.radius * 2.0F;
+    // Sakura start - optimise paper explosions
+    protected final AABB getExplosionBounds(float f) {
         int i = Mth.floor(this.center.x - (double) f - 1.0D);
         int j = Mth.floor(this.center.x + (double) f + 1.0D);
         int k = Mth.floor(this.center.y - (double) f - 1.0D);
         int l = Mth.floor(this.center.y + (double) f + 1.0D);
         int i1 = Mth.floor(this.center.z - (double) f - 1.0D);
         int j1 = Mth.floor(this.center.z + (double) f + 1.0D);
-        List<Entity> list = this.level.getEntities(excludeSourceFromDamage ? this.source : null, new AABB((double) i, (double) k, (double) i1, (double) j, (double) l, (double) j1), (com.google.common.base.Predicate<Entity>) entity -> entity.isAlive() && !entity.isSpectator()); // Paper - Fix lag from explosions processing dead entities, Allow explosions to damage source
-        Iterator iterator = list.iterator();
+        return new AABB((double) i, (double) k, (double) i1, (double) j, (double) l, (double) j1);
+    }
 
-        while (iterator.hasNext()) {
-            Entity entity = (Entity) iterator.next();
+    private void hurtEntities() {
+        float f = this.radius * 2.0F;
+
+        int minSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMinSection(this.level);
+        int maxSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMaxSection(this.level);
+
+        int minChunkX = Mth.floor(this.center.x - f) >> 4;
+        int maxChunkX = Mth.floor(this.center.x + f) >> 4;
+        int minChunkY = Mth.clamp(Mth.floor(this.center.y - f) >> 4, minSection, maxSection);
+        int maxChunkY = Mth.clamp(Mth.floor(this.center.y + f) >> 4, minSection, maxSection);
+        int minChunkZ = Mth.floor(this.center.z - f) >> 4;
+        int maxChunkZ = Mth.floor(this.center.z + f) >> 4;
+
+        ca.spottedleaf.moonrise.patches.chunk_system.level.entity.EntityLookup entityLookup = this.level.moonrise$getEntityLookup();
+        for (int chunkX = minChunkX; chunkX <= maxChunkX; ++chunkX) {
+            for (int chunkZ = minChunkZ; chunkZ <= maxChunkZ; ++chunkZ) {
+                ca.spottedleaf.moonrise.patches.chunk_system.level.entity.ChunkEntitySlices chunk = entityLookup.getChunk(chunkX, chunkZ);
+                if (chunk == null) continue; // empty slice
+
+                for (int chunkY = minChunkY; chunkY <= maxChunkY; ++chunkY) {
+                    this.impactEntities(f, chunk.getSectionEntities(chunkY));
+                }
+            }
+        }
+    }
+
+    protected final void impactEntities(float f, Entity[] entities) {
+        for (int i = 0; i < entities.length; i++) {
+            Entity entity = entities[i];
+            if (entity == null) break;      // end of entity section
+            this.impactEntity(f, entity);
+            if (entity != entities[i]) i--; // entities can be removed mid-explosion
+        }
+    }
+
+    protected final void impactEntity(float f, Entity entity) {
+        if (entity.isAlive() && !entity.isSpectator() && (!this.excludeSourceFromDamage || entity != this.source)) { // Paper - Fix lag from explosions processing dead entities, Allow explosions to damage source
+            // Sakura end - optimise paper explosions
 
             if (!entity.ignoreExplosion(this)) {
                 double d0 = Math.sqrt(entity.distanceToSqr(this.center)) / (double) f;
@@ -508,15 +583,16 @@ public class ServerExplosion implements Explosion {
                             // - Damaging EntityEnderDragon does nothing
                             // - EntityEnderDragon hitbock always covers the other parts and is therefore always present
                             if (entity instanceof EnderDragonPart) {
-                                continue;
+                                return; // Sakura - optimise paper explosions
                             }
 
                             entity.lastDamageCancelled = false;
 
                             if (entity instanceof EnderDragon) {
+                                AABB bounds = this.getExplosionBounds(f); // Sakura - optimise paper explosions
                                 for (EnderDragonPart entityComplexPart : ((EnderDragon) entity).subEntities) {
                                     // Calculate damage separately for each EntityComplexPart
-                                    if (list.contains(entityComplexPart)) {
+                                    if (entityComplexPart.getBoundingBox().intersects(bounds)) { // Sakura - optimise paper explosions
                                         entityComplexPart.hurtServer(this.level, this.damageSource, this.damageCalculator.getEntityDamageAmount(this, entity, f2));
                                     }
                                 }
@@ -525,7 +601,7 @@ public class ServerExplosion implements Explosion {
                             }
 
                             if (entity.lastDamageCancelled) { // SPIGOT-5339, SPIGOT-6252, SPIGOT-6777: Skip entity if damage event was cancelled
-                                continue;
+                                return; // Sakura - optimise paper explosions
                             }
                             // CraftBukkit end
                         }
