From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Samsuik <kfian294ma4@gmail.com>
Date: Sat, 11 Sep 2021 19:19:41 +0100
Subject: [PATCH] Load Chunks on Movement


diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/collisions/CollisionUtil.java b/src/main/java/ca/spottedleaf/moonrise/patches/collisions/CollisionUtil.java
index aec503ca1551ce4b15b8975832cd664ebd670722..f6be260f942c6b9c65e8c3ed625639db75086267 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/collisions/CollisionUtil.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/collisions/CollisionUtil.java
@@ -1912,6 +1912,7 @@ public final class CollisionUtil {
     public static final int COLLISION_FLAG_COLLIDE_WITH_UNLOADED_CHUNKS = 1 << 1;
     public static final int COLLISION_FLAG_CHECK_BORDER = 1 << 2;
     public static final int COLLISION_FLAG_CHECK_ONLY = 1 << 3;
+    public static final int COLLISION_FLAG_ADD_TICKET = 1 << 4; // Sakura - load chunks on movement
 
     public static boolean getCollisionsForBlocksOrWorldBorder(final Level world, final Entity entity, final AABB aabb,
                                                               final List<VoxelShape> intoVoxel, final List<AABB> intoAABB,
@@ -1963,6 +1964,7 @@ public final class CollisionUtil {
         final int maxChunkZ = maxBlockZ >> 4;
 
         final boolean loadChunks = (collisionFlags & COLLISION_FLAG_LOAD_CHUNKS) != 0;
+        final boolean addTicket  = (collisionFlags & COLLISION_FLAG_ADD_TICKET) != 0; // Sakura - load chunks on movement
         final ChunkSource chunkSource = world.getChunkSource();
 
         for (int currChunkZ = minChunkZ; currChunkZ <= maxChunkZ; ++currChunkZ) {
@@ -1981,6 +1983,13 @@ public final class CollisionUtil {
                     continue;
                 }
 
+                // Sakura start - load chunks on movement
+                if (addTicket && chunk.movementTicketNeedsUpdate() && chunkSource instanceof net.minecraft.server.level.ServerChunkCache chunkCache) {
+                    final long chunkKey = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(currChunkX, currChunkZ);
+                    chunkCache.chunkMap.getDistanceManager().moonrise$getChunkHolderManager().addTicketAtLevel(net.minecraft.server.level.TicketType.ENTITY_MOVEMENT, currChunkX, currChunkZ, 31, chunkKey);
+                    chunk.updatedMovementTicket();
+                }
+                // Sakura end - load chunks on movement
                 final LevelChunkSection[] sections = chunk.getSections();
 
                 // bound y
diff --git a/src/main/java/net/minecraft/server/level/TicketType.java b/src/main/java/net/minecraft/server/level/TicketType.java
index e701f57ac8b0efdf739389f9be7a255220bb3e21..35a437f3acfd2659341abd8ab6a3b21c00594ba9 100644
--- a/src/main/java/net/minecraft/server/level/TicketType.java
+++ b/src/main/java/net/minecraft/server/level/TicketType.java
@@ -26,6 +26,7 @@ public class TicketType<T> {
     public static final TicketType<ChunkPos> UNKNOWN = TicketType.create("unknown", Comparator.comparingLong(ChunkPos::toLong), 1);
     public static final TicketType<Unit> PLUGIN = TicketType.create("plugin", (a, b) -> 0); // CraftBukkit
     public static final TicketType<org.bukkit.plugin.Plugin> PLUGIN_TICKET = TicketType.create("plugin_ticket", (plugin1, plugin2) -> plugin1.getClass().getName().compareTo(plugin2.getClass().getName())); // CraftBukkit
+    public static final TicketType<Long> ENTITY_MOVEMENT = TicketType.create("entity_movement", Long::compareTo, 10*20); // Sakura - load chunks on movement
 
     public static <T> TicketType<T> create(String name, Comparator<T> argumentComparator) {
         return new TicketType<>(name, argumentComparator, 0L);
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 4896f3334546b55385e93262dc1a16ef8bda7c45..d16ed3ea0ae380ddccb28a99062c7cccf84c4877 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -616,6 +616,20 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     public boolean isPrimedTNT;
     public boolean isFallingBlock;
     // Sakura end - visibility api and command
+    // Sakura start - load chunks on movement
+    protected boolean loadChunks = false;
+
+    private int getExtraCollisionFlags() {
+        int flags = 0;
+
+        if (this.loadChunks) {
+            flags |= ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_LOAD_CHUNKS;
+            flags |= ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_ADD_TICKET;
+        }
+
+        return flags;
+    }
+    // Sakura end - load chunks on movement
 
     public Entity(EntityType<?> type, Level world) {
         this.id = Entity.ENTITY_COUNTER.incrementAndGet();
@@ -1600,7 +1614,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
 
         ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getCollisionsForBlocksOrWorldBorder(
             this.level, (Entity)(Object)this, initialCollisionBox, potentialCollisionsVoxel, potentialCollisionsBB,
-            ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_BORDER, null
+            ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_BORDER  | this.getExtraCollisionFlags(), null // Sakura - load chunks on movement
         );
         potentialCollisionsBB.addAll(entityAABBs);
         final Vec3 collided = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.performCollisions(movement, currentBox, potentialCollisionsVoxel, potentialCollisionsBB);
@@ -5243,12 +5257,12 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
 
     @Override
     public boolean shouldBeSaved() {
-        return this.removalReason != null && !this.removalReason.shouldSave() ? false : (this.isPassenger() ? false : !this.isVehicle() || !((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity)this).moonrise$hasAnyPlayerPassengers()); // Paper - rewrite chunk system
+        return this.removalReason != null && !this.removalReason.shouldSave() ? false : (this.loadChunks || this.isPassenger() ? false : !this.isVehicle() || !((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity)this).moonrise$hasAnyPlayerPassengers()); // Sakura - load chunks on movement; used to determine whether a chunk should unload // Paper - rewrite chunk system
     }
 
     @Override
     public boolean isAlwaysTicking() {
-        return false;
+        return this.loadChunks; // Sakura - load chunks on movement; always tick in unloaded & lazy chunks
     }
 
     public boolean mayInteract(ServerLevel world, BlockPos pos) {
diff --git a/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java b/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java
index 4a50ef9b25b9162815b879c60c294ed4be2edd5c..6127993804a8c0b342d74c62f163b8371f7c049b 100644
--- a/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java
+++ b/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java
@@ -79,6 +79,7 @@ public class FallingBlockEntity extends Entity {
         this.dropItem = true;
         this.fallDamageMax = 40;
         this.isFallingBlock = true; // Sakura
+        this.loadChunks = world.sakuraConfig().cannons.loadChunks; // Sakura - load chunks on movement
     }
 
     public FallingBlockEntity(Level world, double x, double y, double z, BlockState block) {
diff --git a/src/main/java/net/minecraft/world/entity/item/PrimedTnt.java b/src/main/java/net/minecraft/world/entity/item/PrimedTnt.java
index eff8a8353b513da72e18f993fd41494291bdff3a..2ddfea0dd64cf6a2295583b747ab195346c24530 100644
--- a/src/main/java/net/minecraft/world/entity/item/PrimedTnt.java
+++ b/src/main/java/net/minecraft/world/entity/item/PrimedTnt.java
@@ -64,6 +64,7 @@ public class PrimedTnt extends Entity implements TraceableEntity {
         this.explosionPower = 4.0F;
         this.blocksBuilding = true;
         this.isPrimedTNT = true; // Sakura
+        this.loadChunks = world.sakuraConfig().cannons.loadChunks; // Sakura - load chunks on movement
     }
 
     public PrimedTnt(Level world, double x, double y, double z, @Nullable LivingEntity igniter) {
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
index a402e2f774cfc062afab8d86969f3e6f38874063..d95c15bff4e7ab241c63b0abeaaaca0d07fd77ae 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
@@ -140,6 +140,17 @@ public abstract class ChunkAccess implements BiomeManager.NoiseBiomeSource, Ligh
     private final int minSection;
     private final int maxSection;
     // Paper end - get block chunk optimisation
+    // Sakura start - load chunks on movement
+    private long lastMovementLoadTicket = 0;
+
+    public final boolean movementTicketNeedsUpdate() {
+        return net.minecraft.server.MinecraftServer.currentTick - this.lastMovementLoadTicket >= 100;
+    }
+
+    public final void updatedMovementTicket() {
+        this.lastMovementLoadTicket = net.minecraft.server.MinecraftServer.currentTick;
+    }
+    // Sakura end - load chunks on movement
 
     public ChunkAccess(ChunkPos pos, UpgradeData upgradeData, LevelHeightAccessor heightLimitView, Registry<Biome> biomeRegistry, long inhabitedTime, @Nullable LevelChunkSection[] sectionArray, @Nullable BlendingData blendingData) {
         this.locX = pos.x; this.locZ = pos.z; // Paper - reduce need for field lookups
