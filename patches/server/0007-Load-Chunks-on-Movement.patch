From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Samsuik <kfian294ma4@gmail.com>
Date: Sat, 11 Sep 2021 19:19:41 +0100
Subject: [PATCH] Load Chunks on Movement


diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/collisions/CollisionUtil.java b/src/main/java/ca/spottedleaf/moonrise/patches/collisions/CollisionUtil.java
index e04bd54744335fb5398c6e4f7ce8b981f35bfb7d..651a45b795818bd7b1364b95c52570fd99dd35e4 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/collisions/CollisionUtil.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/collisions/CollisionUtil.java
@@ -1885,6 +1885,7 @@ public final class CollisionUtil {
     public static final int COLLISION_FLAG_COLLIDE_WITH_UNLOADED_CHUNKS = 1 << 1;
     public static final int COLLISION_FLAG_CHECK_BORDER = 1 << 2;
     public static final int COLLISION_FLAG_CHECK_ONLY = 1 << 3;
+    public static final int COLLISION_FLAG_ADD_TICKET = 1 << 4; // Sakura - load chunks on movement
 
     public static boolean getCollisionsForBlocksOrWorldBorder(final Level world, final Entity entity, final AABB aabb,
                                                               final List<VoxelShape> intoVoxel, final List<AABB> intoAABB,
@@ -1936,6 +1937,7 @@ public final class CollisionUtil {
         final int maxChunkZ = maxBlockZ >> 4;
 
         final boolean loadChunks = (collisionFlags & COLLISION_FLAG_LOAD_CHUNKS) != 0;
+        final boolean addTicket  = (collisionFlags & COLLISION_FLAG_ADD_TICKET) != 0; // Sakura - load chunks on movement
         final ChunkSource chunkSource = world.getChunkSource();
 
         for (int currChunkZ = minChunkZ; currChunkZ <= maxChunkZ; ++currChunkZ) {
@@ -1954,6 +1956,13 @@ public final class CollisionUtil {
                     continue;
                 }
 
+                // Sakura start - load chunks on movement
+                if (addTicket && chunk.movementTicketNeedsUpdate() && chunkSource instanceof net.minecraft.server.level.ServerChunkCache chunkCache) {
+                    final long chunkKey = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(currChunkX, currChunkZ);
+                    chunkCache.chunkMap.getDistanceManager().moonrise$getChunkHolderManager().addTicketAtLevel(net.minecraft.server.level.TicketType.ENTITY_MOVEMENT, currChunkX, currChunkZ, 31, chunkKey);
+                    chunk.updatedMovementTicket();
+                }
+                // Sakura end - load chunks on movement
                 final LevelChunkSection[] sections = chunk.getSections();
 
                 // bound y
diff --git a/src/main/java/net/minecraft/server/level/TicketType.java b/src/main/java/net/minecraft/server/level/TicketType.java
index 4d3f7d4a8e05a8d84aa5202134eda1ce9621712e..db159b9b4ffc032f5abe68bf294e58cce04e1baa 100644
--- a/src/main/java/net/minecraft/server/level/TicketType.java
+++ b/src/main/java/net/minecraft/server/level/TicketType.java
@@ -26,6 +26,7 @@ public class TicketType<T> {
     public static final TicketType<Unit> PLUGIN = TicketType.create("plugin", (a, b) -> 0); // CraftBukkit
     public static final TicketType<org.bukkit.plugin.Plugin> PLUGIN_TICKET = TicketType.create("plugin_ticket", (plugin1, plugin2) -> plugin1.getClass().getName().compareTo(plugin2.getClass().getName())); // CraftBukkit
     public static final TicketType<Integer> POST_TELEPORT = TicketType.create("post_teleport", Integer::compare, 5); // Paper - post teleport ticket type
+    public static final TicketType<Long> ENTITY_MOVEMENT = TicketType.create("entity_movement", Long::compareTo, 10*20); // Sakura - load chunks on movement
 
     public static <T> TicketType<T> create(String name, Comparator<T> argumentComparator) {
         return new TicketType<>(name, argumentComparator, 0L);
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 29045a4857aadbc7f9ae0c612555743ad404682d..031d3fde74a08165dc6b8106246249583c2300c0 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -572,6 +572,20 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     public boolean isPrimedTNT;
     public boolean isFallingBlock;
     // Sakura end - visibility api and command
+    // Sakura start - load chunks on movement
+    protected boolean loadChunks = false;
+
+    private int getExtraCollisionFlags() {
+        int flags = 0;
+
+        if (this.loadChunks) {
+            flags |= ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_LOAD_CHUNKS;
+            flags |= ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_ADD_TICKET;
+        }
+
+        return flags;
+    }
+    // Sakura end - load chunks on movement
 
     public Entity(EntityType<?> type, Level world) {
         this.id = Entity.ENTITY_COUNTER.incrementAndGet();
@@ -1569,7 +1583,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
 
         ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getCollisionsForBlocksOrWorldBorder(
             this.level, (Entity)(Object)this, initialCollisionBox, potentialCollisionsVoxel, potentialCollisionsBB,
-            ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_BORDER, null
+            ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_BORDER  | this.getExtraCollisionFlags(), null // Sakura - load chunks on movement
         );
         potentialCollisionsBB.addAll(entityAABBs);
         final Vec3 collided = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.performCollisions(movement, currentBox, potentialCollisionsVoxel, potentialCollisionsBB);
@@ -5229,12 +5243,12 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
 
     @Override
     public boolean shouldBeSaved() {
-        return this.removalReason != null && !this.removalReason.shouldSave() ? false : (this.isPassenger() ? false : !this.isVehicle() || !((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity)this).moonrise$hasAnyPlayerPassengers()); // Paper - rewrite chunk system
+        return this.removalReason != null && !this.removalReason.shouldSave() ? false : (this.loadChunks || this.isPassenger() ? false : !this.isVehicle() || !((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity)this).moonrise$hasAnyPlayerPassengers()); // Sakura - load chunks on movement; used to determine whether a chunk should unload // Paper - rewrite chunk system
     }
 
     @Override
     public boolean isAlwaysTicking() {
-        return false;
+        return this.loadChunks; // Sakura - load chunks on movement; always tick in unloaded & lazy chunks
     }
 
     public boolean mayInteract(ServerLevel world, BlockPos pos) {
diff --git a/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java b/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java
index e270eaec13afb16ed80e7c3fd8ea35ee58291263..20fa9a70f2d51aaa7f9ea01150d65c1f73caa374 100644
--- a/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java
+++ b/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java
@@ -79,6 +79,7 @@ public class FallingBlockEntity extends Entity {
         this.dropItem = true;
         this.fallDamageMax = 40;
         this.isFallingBlock = true; // Sakura
+        this.loadChunks = world.sakuraConfig().cannons.loadChunks; // Sakura - load chunks on movement
     }
 
     public FallingBlockEntity(Level world, double x, double y, double z, BlockState block) {
diff --git a/src/main/java/net/minecraft/world/entity/item/PrimedTnt.java b/src/main/java/net/minecraft/world/entity/item/PrimedTnt.java
index a7bcf197f062361c764d4e951ed88678994eca17..539219a4117c67278461ee483a457c005e6edcfc 100644
--- a/src/main/java/net/minecraft/world/entity/item/PrimedTnt.java
+++ b/src/main/java/net/minecraft/world/entity/item/PrimedTnt.java
@@ -64,6 +64,7 @@ public class PrimedTnt extends Entity implements TraceableEntity {
         this.explosionPower = 4.0F;
         this.blocksBuilding = true;
         this.isPrimedTNT = true; // Sakura
+        this.loadChunks = world.sakuraConfig().cannons.loadChunks; // Sakura - load chunks on movement
     }
 
     public PrimedTnt(Level world, double x, double y, double z, @Nullable LivingEntity igniter) {
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
index f87abb22dd161b2b74401086de80dc95c9ac2dbb..af1624aeda1ca72973b2b63ef05cd7367f678414 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
@@ -140,6 +140,17 @@ public abstract class ChunkAccess implements BiomeManager.NoiseBiomeSource, Ligh
     private final int minSection;
     private final int maxSection;
     // Paper end - get block chunk optimisation
+    // Sakura start - load chunks on movement
+    private long lastMovementLoadTicket = 0;
+
+    public final boolean movementTicketNeedsUpdate() {
+        return net.minecraft.server.MinecraftServer.currentTick - this.lastMovementLoadTicket >= 100;
+    }
+
+    public final void updatedMovementTicket() {
+        this.lastMovementLoadTicket = net.minecraft.server.MinecraftServer.currentTick;
+    }
+    // Sakura end - load chunks on movement
 
     public ChunkAccess(ChunkPos pos, UpgradeData upgradeData, LevelHeightAccessor heightLimitView, Registry<Biome> biomeRegistry, long inhabitedTime, @Nullable LevelChunkSection[] sectionArray, @Nullable BlendingData blendingData) {
         this.locX = pos.x; this.locZ = pos.z; // Paper - reduce need for field lookups
