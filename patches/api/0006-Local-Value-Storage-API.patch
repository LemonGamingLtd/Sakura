From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Samsuik <40902469+Samsuik@users.noreply.github.com>
Date: Tue, 21 Nov 2023 23:22:35 +0000
Subject: [PATCH] Local Value Storage API


diff --git a/src/main/java/me/samsuik/sakura/local/LocalRegion.java b/src/main/java/me/samsuik/sakura/local/LocalRegion.java
new file mode 100644
index 0000000000000000000000000000000000000000..6f76eae76ab40c0aa9e53d66df9af9827d067dda
--- /dev/null
+++ b/src/main/java/me/samsuik/sakura/local/LocalRegion.java
@@ -0,0 +1,41 @@
+package me.samsuik.sakura.local;
+
+import io.papermc.paper.math.Position;
+import org.bukkit.util.Vector;
+import org.jspecify.annotations.NullMarked;
+
+@NullMarked
+public record LocalRegion(int minX, int minZ, int maxX, int maxZ) {
+    public static LocalRegion of(Vector min, Vector max) {
+        return of(min.getBlockX(), min.getBlockZ(), max.getBlockX(), max.getBlockZ());
+    }
+
+    public static LocalRegion of(Position min, Position max) {
+        return of(min.blockX(), min.blockZ(), max.blockX(), max.blockZ());
+    }
+
+    public static LocalRegion of(int minX, int minZ, int maxX, int maxZ) {
+        return new LocalRegion(
+            Math.min(minX, maxX), Math.min(minZ, maxZ),
+            Math.max(minX, maxX), Math.max(minZ, maxZ)
+        );
+    }
+
+    public static LocalRegion at(int x, int z, int radius) {
+        return new LocalRegion(x-radius, z-radius, x+radius, z+radius);
+    }
+
+    public boolean intersects(LocalRegion region) {
+        return (this.minX < region.minX() && this.maxX > region.minX() || this.maxX > region.maxX() && this.minX < region.maxX())
+            && (this.minZ < region.minZ() && this.maxZ > region.minZ() || this.maxZ > region.maxZ() && this.minZ < region.maxZ());
+    }
+
+    public boolean contains(LocalRegion region) {
+        return this.minX < region.minX() && this.maxX > region.maxX()
+            && this.maxZ < region.minZ() && this.maxZ > region.maxZ();
+    }
+
+    public boolean contains(int x, int z) {
+        return this.minX <= x && this.maxX >= x && this.minZ <= z && this.maxZ >= z;
+    }
+}
diff --git a/src/main/java/me/samsuik/sakura/local/LocalValueKey.java b/src/main/java/me/samsuik/sakura/local/LocalValueKey.java
new file mode 100644
index 0000000000000000000000000000000000000000..adb2048a02e71433618b26a14f4c71f0e26fe943
--- /dev/null
+++ b/src/main/java/me/samsuik/sakura/local/LocalValueKey.java
@@ -0,0 +1,26 @@
+package me.samsuik.sakura.local;
+
+import org.bukkit.NamespacedKey;
+import org.jspecify.annotations.NullMarked;
+
+import java.util.Objects;
+import java.util.function.Supplier;
+
+@NullMarked
+public record LocalValueKey<T>(NamespacedKey key, Supplier<T> defaultSupplier) {
+    // ...
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || this.getClass() != o.getClass()) return false;
+
+        LocalValueKey<?> that = (LocalValueKey<?>) o;
+        return this.key.equals(that.key);
+    }
+
+    @Override
+    public int hashCode() {
+        return this.key.hashCode();
+    }
+}
diff --git a/src/main/java/me/samsuik/sakura/local/storage/LocalStorageHandler.java b/src/main/java/me/samsuik/sakura/local/storage/LocalStorageHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..220a12eddf3aeaeb7adfd6404b5225e392439ca8
--- /dev/null
+++ b/src/main/java/me/samsuik/sakura/local/storage/LocalStorageHandler.java
@@ -0,0 +1,22 @@
+package me.samsuik.sakura.local.storage;
+
+import me.samsuik.sakura.local.LocalRegion;
+import org.bukkit.Location;
+
+import java.util.List;
+
+public interface LocalStorageHandler {
+    LocalRegion locate(Location location, int searchDistance);
+
+    LocalRegion locate(int x, int z, int searchDistance);
+
+    LocalValueStorage get(LocalRegion region);
+
+    boolean has(LocalRegion region);
+
+    void put(LocalRegion region, LocalValueStorage storage);
+
+    void remove(LocalRegion region);
+
+    List<LocalRegion> regions();
+}
diff --git a/src/main/java/me/samsuik/sakura/local/storage/LocalValueStorage.java b/src/main/java/me/samsuik/sakura/local/storage/LocalValueStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..791637f4c817b32e30b47a88adc5a525389cdcdd
--- /dev/null
+++ b/src/main/java/me/samsuik/sakura/local/storage/LocalValueStorage.java
@@ -0,0 +1,42 @@
+package me.samsuik.sakura.local.storage;
+
+import me.samsuik.sakura.local.LocalValueKey;
+import org.jspecify.annotations.NullMarked;
+
+import java.util.HashMap;
+import java.util.Map;
+
+@NullMarked
+@SuppressWarnings("unchecked")
+public final class LocalValueStorage {
+    private final Map<LocalValueKey<?>, Object> map = new HashMap<>();
+
+    public boolean exists(LocalValueKey<?> key) {
+        return this.map.containsKey(key);
+    }
+
+    public <T> T value(LocalValueKey<T> key) {
+        return (T) this.map.get(key);
+    }
+
+    public <T> T value(LocalValueKey<T> key, boolean returnDefault) {
+        T val = (T) this.map.get(key);
+        if (!returnDefault || val != null)
+            return val;
+        // update value
+        this.set(key, val = key.defaultSupplier().get());
+        return val;
+    }
+
+    public <T> T getOrDefault(LocalValueKey<T> key, T def) {
+        return (T) this.map.getOrDefault(key, def);
+    }
+
+    public <T> void set(LocalValueKey<T> key, T insert) {
+        this.map.put(key, insert);
+    }
+
+    public void remove(LocalValueKey<?> key) {
+        this.map.remove(key);
+    }
+}
diff --git a/src/main/java/org/bukkit/World.java b/src/main/java/org/bukkit/World.java
index ef32a937e6faf1e8a5d6b1207986715bae5a246c..9ef129370e7773e256fe4d2d3bfe93abc625b26a 100644
--- a/src/main/java/org/bukkit/World.java
+++ b/src/main/java/org/bukkit/World.java
@@ -205,6 +205,10 @@ public interface World extends RegionAccessor, WorldInfo, PluginMessageRecipient
         return new Location(this, x, y, z);
     }
     // Paper end
+    // Sakura start
+    @NotNull
+    me.samsuik.sakura.local.storage.LocalStorageHandler getStorageHandler();
+    // Sakura end
 
     /**
      * Gets the highest non-empty (impassable) block at the given coordinates.
